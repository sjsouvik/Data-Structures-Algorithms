/*
Construct a binary tree of size N using 2 given arrays pre[] and preLN[]. Array pre[] represents preorder traversal of a binary tree. Array preLN[] has 
only two possible values ‘L’ and ‘N’. The value ‘L’ in preLN[] indicates that the corresponding node in Binary Tree is a leaf node and value ‘N’ indicates 
that the corresponding node is a non-leaf node.
Note: Every node in the binary tree has either 0 or 2 children.

Example 1:

Input :      
N = 5
pre[] = {10, 30, 20, 5, 15}
preLN[] = {N, N, L, L, L}

Output:
          10
        /    \
      30      15
     /  \     
   20    5   

 

Your Task:  
You dont need to read input or print anything. Complete the function constructTree() which takes N, pre[] and preLN[] as input parameters and returns the 
root node of the constructed binary tree.
Note: The output generated by the compiler will contain the inorder traversal of the created binary tree.
 

Expected Time Complexity: O(N)
Expected Auxiliary Space: O(N)


Constraints:
1 ≤ N ≤ 104
1 ≤ pre[i] ≤ 107
preLN[i]: {'N', 'L'}

*******************************************************************Solution****************************************************************************/

import java.util.Scanner;
import java.lang.Math;
import java.io.*;

class Node
{
    int data;
    Node left,right;
    Node(int d)
    {
        data=d;
        left=right=null;
    }
}

class GFG2
{
    public static void inorder(Node root)
    {
        if(root==null)
        return;
        inorder(root.left);
        System.out.print(root.data+" ");
        inorder(root.right);
    }

    public static void main(String args[])
    {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        while(t-->0)
        {
            int n=sc.nextInt();
            int []pre=new int[n];
            char []preLN=new char[n];
            for(int i=0;i<n;i++)
            {
                int b=sc.nextInt();
                pre[i]=b;
            }
            for(int i=0;i<n;i++)
            {
                char c=sc.next().charAt(0);
                preLN[i]=c;
            }
            GFG obj=new GFG();
            Node root=obj.constructTree(n,pre,preLN);
            inorder(root);
            System.out.println();
        }
    }
}


class GFG
{
    int index = 0;
    
    Node constructTree(int n, int pre[], char preLN[])
    {
            if(index == n)
            	return null;
        
            int data = pre[index]; 
	    
	    if(preLN[index++] == 'L')
	    {
	        Node root = new Node(data);
	        root.left = null;
	        root.right = null;
                return root;
	    }
	    
	    Node root = new Node(data);
	    root.left = constructTree(n, pre, preLN);
	    root.right = constructTree(n, pre, preLN);
	    
	    return root;
    }
}



